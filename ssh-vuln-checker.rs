use std::net::{TcpStream, ToSocketAddrs};
use std::io::{Read, Write};
use std::time::Duration;
use std::env;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::str::FromStr;
use std::collections::HashSet;

const GREEN: &str = "\x1b[92m";
const RED: &str = "\x1b[91m";
const YELLOW: &str = "\x1b[93m";
const ORANGE: &str = "\x1b[33m";
const ENDC: &str = "\x1b[0m";

// Define known vulnerable and patched versions
const VULNERABLE_VERSIONS: [&str; 19] = [
    "SSH-2.0-OpenSSH_1", "SSH-2.0-OpenSSH_2", "SSH-2.0-OpenSSH_3", "SSH-2.0-OpenSSH_4.0",
    "SSH-2.0-OpenSSH_4.1", "SSH-2.0-OpenSSH_4.2", "SSH-2.0-OpenSSH_4.3", "SSH-2.0-OpenSSH_4.4",
    "SSH-2.0-OpenSSH_8.5", "SSH-2.0-OpenSSH_8.6", "SSH-2.0-OpenSSH_8.7", "SSH-2.0-OpenSSH_8.8",
    "SSH-2.0-OpenSSH_8.9", "SSH-2.0-OpenSSH_9.0", "SSH-2.0-OpenSSH_9.1", "SSH-2.0-OpenSSH_9.2",
    "SSH-2.0-OpenSSH_9.3", "SSH-2.0-OpenSSH_9.4", "SSH-2.0-OpenSSH_9.5", "SSH-2.0-OpenSSH_9.6",
    "SSH-2.0-OpenSSH_9.7"
];

const PATCHED_VERSIONS: [&str; 7] = [
    "SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.10", "SSH-2.0-OpenSSH_9.3p1 Ubuntu-3ubuntu3.6",
    "SSH-2.0-OpenSSH_9.6p1 Ubuntu-3ubuntu13.3", "SSH-2.0-OpenSSH_9.3p1 Ubuntu-1ubuntu3.6",
    "SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u3", "SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u3",
    "SSH-2.0-OpenSSH_9.7p1 Debian-7"
];

fn display_banner() {
    let banner = format!(
        r#"
{}  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  + CVE-2024-6387 Vulnerability Checker                       +
  + Created by senhasegura Identity Threat Labs               +
  + Filipi Pires - Threat Researcher & Cybersecurity Advocate +
  + @senhasegura / @filipipires                               +
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
{}"#,
        GREEN, ENDC
    );
    println!("{}", banner);
}

fn resolve_hostname(hostname: &str) -> Option<String> {
    match hostname.to_socket_addrs() {
        Ok(mut addrs) => addrs.next().map(|addr| addr.ip().to_string()),
        Err(_) => None,
    }
}

fn get_ssh_banner(ip: &str, port: u16, timeout: Duration) -> Option<String> {
    match TcpStream::connect_timeout(&(ip, port).into(), timeout) {
        Ok(mut stream) => {
            stream.set_read_timeout(Some(timeout)).unwrap();
            let mut buffer = [0; 1024];
            match stream.read(&mut buffer) {
                Ok(n) => {
                    let banner = String::from_utf8_lossy(&buffer[..n]).trim().to_string();
                    Some(banner)
                }
                Err(_) => None,
            }
        }
        Err(_) => None,
    }
}

fn check_vulnerability(address: &str, port: u16, timeout: Duration) -> (String, u16, &'static str, String) {
    let ip = if !address.replace(".", "").chars().all(char::is_numeric) {
        resolve_hostname(address).unwrap_or_else(|| address.to_string())
    } else {
        address.to_string()
    };

    let banner = get_ssh_banner(&ip, port, timeout);
    let banner = match banner {
        Some(b) => b,
        None => return (ip, port, "ERROR", " WE COULDN'T CONNECT OR RETRIEVE BANNER".to_string()),
    };

    if banner.starts_with("SSH-2.0-OpenSSH") {
        if VULNERABLE_VERSIONS.contains(&banner.as_str()) && !PATCHED_VERSIONS.contains(&banner.as_str()) {
            (ip, port, "VULNERABLE", format!("-> Running {}", banner))
        } else {
            (ip, port, "SAFE", format!("-> Running {}", banner))
        }
    } else {
        (ip, port, "UNKNOWN", format!("-> SSH version {}", banner))
    }
}

fn main() {
    display_banner();

    let args: Vec<String> = env::args().collect();
    let mut addresses: Vec<String> = Vec::new();
    let mut ports: Vec<u16> = vec![22];
    let mut timeout: u64 = 5;

    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {
            "-f" | "--file" if i + 1 < args.len() => {
                let file_path = &args[i + 1];
                let file = File::open(file_path).expect("Unable to open file");
                let reader = BufReader::new(file);
                for line in reader.lines() {
                    if let Ok(line) = line {
                        addresses.push(line.trim().to_string());
                    }
                }
                i += 2;
            }
            "-p" | "--ports" if i + 1 < args.len() => {
                ports = args[i + 1].split(',').map(|p| u16::from_str(p).unwrap()).collect();
                i += 2;
            }
            "-t" | "--timeout" if i + 1 < args.len() => {
                timeout = args[i + 1].parse().expect("Timeout must be a valid number");
                i += 2;
            }
            _ => {
                addresses.push(args[i].clone());
                i += 1;
            }
        }
    }

    let mut results = HashSet::new();

    for address in addresses {
        for port in &ports {
            let (ip, port, status, message) = check_vulnerability(&address, *port, Duration::from_secs(timeout));
            results.insert((status.to_string(), ip, port, message));
        }
    }

    let mut safe_results = Vec::new();
    let mut vulnerable_results = Vec::new();
    let mut unknown_results = Vec::new();
    let mut error_results = Vec::new();

    for (status, ip, port, message) in results {
        match status.as_str() {
            "SAFE" => safe_results.push((ip, port, message)),
            "VULNERABLE" => vulnerable_results.push((ip, port, message)),
            "UNKNOWN" => unknown_results.push((ip, port, message)),
            "ERROR" => error_results.push((ip, port, message)),
            _ => {}
        }
    }

    if !safe_results.is_empty() {
        println!("\n{}SERVER NOT VULNERABLE: {}{}", GREEN, safe_results.len(), ENDC);
        for (ip, port, msg) in safe_results {
            println!("{}[SAFE] -> {}:{}", GREEN, ip, port);
            println!("{}{}{}{}", GREEN, msg, ENDC);
        }
    }

    if !vulnerable_results.is_empty() {
        println!("\n{}SERVER VULNERABLE: {}{}", RED, vulnerable_results.len(), ENDC);
        for (ip, port, msg) in vulnerable_results {
            println!("{}[VULNERABLE] -> {}:{}", RED, ip, port);
            println!("{}{}{}{}", RED, msg, ENDC);
        }
    }

    if !unknown_results.is_empty() {
        println!("\n{}SERVER UNKNOWN SSH VERSION: {}{}", ORANGE, unknown_results.len(), ENDC);
        for (ip, port, msg) in unknown_results {
            println!("{}[UNKNOWN] -> {}:{}", ORANGE, ip, port);
            println!("{}{}{}{}", ORANGE, msg, ENDC);
        }
    }

    if !error_results.is_empty() {
        println!(
            "\n{}WE COULDN'T CONNECT OR RETRIEVE BANNER: {}{}",
            YELLOW,
            error_results.len(),
            ENDC
        );
        for (ip, port, msg) in error_results {
            println!("{}[ERROR] -> {}:{}", YELLOW, ip, port);
            println!("{}{}{}{}", YELLOW, msg, ENDC);
        }
    }
}
